name: Auto-Fix CI Failures (Improved)

on:
  workflow_run:
    workflows: ["dev-ci"]  # Your main CI workflow name
    types:
      - completed

jobs:
  auto-fix:
    if: ${{ github.event.workflow_run.conclusion == 'failure' && github.event.workflow_run.event == 'pull_request' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Get PR Info
        id: pr-info
        uses: actions/github-script@v7
        with:
          script: |
            const runs = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: context.payload.workflow_run.workflow_id,
              branch: context.payload.workflow_run.head_branch,
              per_page: 1
            });
            
            const pr = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`,
              state: 'open'
            });
            
            if (pr.data.length > 0) {
              core.setOutput('pr_number', pr.data[0].number);
              core.setOutput('pr_branch', context.payload.workflow_run.head_branch);
            } else {
              core.setFailed('No open PR found for branch');
            }

      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          # IMPORTANT: Use a PAT instead of GITHUB_TOKEN to trigger workflows
          token: ${{ secrets.AUTO_FIX_PAT || secrets.GITHUB_TOKEN }}
          ref: ${{ steps.pr-info.outputs.pr_branch }}
          
      - name: Set up Environment
        run: |
          # Install dependencies needed for 'just check'
          curl -qfsSL https://just.systems/install.sh | bash -s -- --to /usr/local/bin
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
          
      - name: Install Python Dependencies
        run: |
          pip install -r requirements-dev.txt || pip install ruff black isort mypy pytest
          
      - name: Download and Analyze Logs
        id: analyze-logs
        run: |
          # Download logs
          gh api /repos/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}/logs \
            -H "Accept: application/vnd.github.v3+json" > logs.zip
          unzip logs.zip
          
          # Extract errors
          python << 'EOF'
          import re
          import json
          import os
          
          errors = []
          fixable_errors = []
          
          # Common CI error patterns
          patterns = {
              'import': r"ImportError: (.+)",
              'module': r"ModuleNotFoundError: (.+)",
              'indent': r"IndentationError: (.+)",
              'syntax': r"SyntaxError: (.+)",
              'type': r"error: (.+)\[type-",
              'mypy': r"error: (.+)",
              'ruff': r"(.+\.py):\d+:\d+: ([A-Z]\d+) (.+)",
              'black': r"error: cannot format (.+):",
          }
          
          for root, dirs, files in os.walk('.'):
              for file in files:
                  if file.endswith('.txt'):
                      with open(os.path.join(root, file), 'r') as f:
                          content = f.read()
                          for error_type, pattern in patterns.items():
                              matches = re.findall(pattern, content)
                              for match in matches:
                                  errors.append({'type': error_type, 'detail': match})
                                  if error_type in ['import', 'module', 'indent', 'syntax', 'ruff', 'black']:
                                      fixable_errors.append({'type': error_type, 'detail': match})
          
          with open('analysis.json', 'w') as f:
              json.dump({
                  'errors': errors[:50],  # Limit to 50 errors
                  'fixable_errors': fixable_errors[:20],
                  'can_fix': len(fixable_errors) > 0
              }, f)
          
          print(f"Found {len(errors)} errors, {len(fixable_errors)} are potentially fixable")
          EOF
          
          # Set outputs
          if [ -f analysis.json ]; then
            can_fix=$(jq -r '.can_fix' analysis.json)
            echo "can_fix=$can_fix" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Apply Automatic Fixes
        if: steps.analyze-logs.outputs.can_fix == 'true'
        id: apply-fixes
        run: |
          echo "Applying automatic fixes..."
          
          # Track changed files
          git diff --name-only > before-files.txt
          
          # Apply formatting fixes
          just lint || true
          
          # Alternative if 'just lint' doesn't exist
          if [ $? -ne 0 ]; then
            echo "Running formatters directly..."
            ruff check . --fix --unsafe-fixes || true
            isort . || true
            black . || true
          fi
          
          # Check for changes
          git diff --name-only > after-files.txt
          if ! diff -q before-files.txt after-files.txt > /dev/null; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate AI Fixes (Optional)
        if: steps.analyze-logs.outputs.can_fix == 'true' && steps.apply-fixes.outputs.has_changes != 'true'
        id: ai-fix
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          # Only if simple fixes didn't work, use AI
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            pip install anthropic
            python << 'EOF'
          import json
          import os
          from anthropic import Anthropic
          
          with open('analysis.json', 'r') as f:
              analysis = json.load(f)
          
          if analysis['fixable_errors']:
              client = Anthropic(api_key=os.environ['ANTHROPIC_API_KEY'])
              
              # Create targeted fix request
              errors_text = '\n'.join([f"{e['type']}: {e['detail']}" for e in analysis['fixable_errors'][:10]])
              
              response = client.messages.create(
                  model="claude-3-opus-20240229",
                  max_tokens=2000,
                  messages=[{
                      "role": "user",
                      "content": f"Fix these Python errors. Provide only the corrected code:\n\n{errors_text}"
                  }]
              )
              
              # Apply suggested fixes (simplified - in practice you'd parse and apply them)
              print("AI suggestions received")
          EOF
          fi
          
      # CRITICAL: Run full validation before committing
      - name: Validate Fixes
        if: steps.apply-fixes.outputs.has_changes == 'true' || steps.ai-fix.outputs.has_changes == 'true'
        id: validate
        run: |
          echo "Running 'just check' to validate all fixes..."
          
          # Run the full check suite
          if just check; then
            echo "✅ All checks passed!"
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Validation failed. Not committing fixes."
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Commit and Push
        if: steps.validate.outputs.validation_passed == 'true'
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Stage only source files (not temp files)
          git add -A
          git reset -- "*.log" "*.txt" "*.md" || true
          
          # Only commit if there are changes
          if [[ -n $(git status -s) ]]; then
            git commit -m "fix: Auto-fix CI failures

Automated fixes applied:
- Code formatting (ruff, black, isort)
- Import sorting
- Linting issues

All fixes validated with 'just check' ✅

Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
            
            # Push with PAT to trigger CI
            git push origin ${{ steps.pr-info.outputs.pr_branch }}
            
            echo "pushed=true" >> $GITHUB_OUTPUT
          else
            echo "No changes to commit"
            echo "pushed=false" >> $GITHUB_OUTPUT
          fi

      - name: Trigger CI Re-run
        if: steps.commit.outputs.pushed == 'true'
        uses: actions/github-script@v7
        with:
          # Use PAT if available for better permissions
          github-token: ${{ secrets.AUTO_FIX_PAT || secrets.GITHUB_TOKEN }}
          script: |
            // Wait a bit for GitHub to process the push
            await new Promise(resolve => setTimeout(resolve, 5000));
            
            // Get the latest commit
            const branch = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: '${{ steps.pr-info.outputs.pr_branch }}'
            });
            
            // Trigger a new workflow run if needed
            // This works better with a PAT that has workflow permissions
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'dev-ci.yml',
                ref: '${{ steps.pr-info.outputs.pr_branch }}'
              });
              console.log('Triggered new CI run');
            } catch (e) {
              console.log('Could not trigger workflow - it may run automatically');
            }

      - name: Comment on PR
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr-info.outputs.pr_number }};
            let comment;
            
            if ('${{ steps.validate.outputs.validation_passed }}' === 'true') {
              comment = `🤖 **CI Auto-Fix Applied**
              
              ✅ Successfully fixed CI failures and validated with \`just check\`
              
              **What was fixed:**
              - Code formatting issues
              - Import ordering  
              - Linting violations
              
              The CI should now pass on the next run.`;
            } else if ('${{ steps.apply-fixes.outputs.has_changes }}' === 'true') {
              comment = `🤖 **CI Auto-Fix Attempted**
              
              ❌ Found and applied fixes, but \`just check\` still fails.
              
              The issues may require manual intervention.`;
            } else {
              comment = `🤖 **CI Auto-Fix Analysis**
              
              ℹ️ Analyzed the CI failure but couldn't apply automatic fixes.
              
              The errors may require manual review.`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });